---
arc: 300
title: Payments and Compliance friendly ecosystem
description: Spec to handle compliant payment solutions
author: Payments Working Group
status: Draft
type: Standards Track
category: Wallets
created: 2024-03-13
---

# Payments and Compliance friendly ecosystem

## Abstract

This ARC intends to provide a specification for handling compliant payment solutions in the Algorand ecosystem. The specification will provide a standard interface for wallets and payment solutions to interact with each other in a way that helps businesses and integrators to comply with regulations and standards.

## Motivation

Given that our ecosystem is extremely attractive to payment solutions, such as integrators, payment providers and businesses, it is important to standardize the way these solutions interact with each other and avoid custom solutions that will put a burden on apps and wallets to support multiple integrations.

### Properties that make Algorand attractive to payment solutions

- `Instant Finality`: Transactions are final as soon as they are included in a block, which if you are a payments integrator, merchant or business, unlike other DLT's or ecosystem you are not operating at risk when reading state from the ledger. 

- `Low Transaction Fees`: Economically viable for integrators and businesses to use Algorand for high volume of payments and settlements

- `Atomic Grouped Operations`: Guaranteed atomicity and sequence of business operations is hard to achieve in a distributed system and often the responsiblity of ordering this correctly is left to the integrator and to the network to ensure that the operations are executed in the correct order. Some system require custom solutions to keep track or order of operations and handle failures or edge cases. Algorand provides a way to group operations and execute them atomically native to the protocol.

- `Whitelisted Asset Ownership`: For regulatory reasons, a business may need to ensure that only own certain assets on the books and avoid unwanted assets, tax liabilities, or other regulatory issues. 

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt).


## Compliance Requirements

- **`Identity`**: It **MUST** have a way to link ledger addresses to real world identities. This is a requirement for KYC/AML and other compliance reasons.

- **`Whitelisting`**: It **MUST**** be able to prove explicitly that a given address is allowed to hold a given asset. 

- **`Privacy`**: Solutions **MUST** ensure user's privacy and data protection. And at the same time be able to provide the necessary information to comply with regulations.

- **`Transaction Monitoring`**: It **MUST**** be able to monitor transactions and provide the necessary information to comply with regulations.

- **`Differentiation of regular transfers and payments`**: Transfers related to payments **SHOULD** be differentiated from regular transfers. This is important for compliance and reporting purposes.

## Identity

To handle the identity requirement, this proposal suggests using an open, alreadly established standard such as [DID](https://www.w3.org/TR/did-core/) (Decentralized Identifiers) and [Verifiable Credentials](https://www.w3.org/TR/vc-data-model/) (VC).

### Wallets

- Wallets **MUST** be able to generate keys and associate them with a DID. 

#### DID Method

Any DID method could be used; however, for a Algorand specific DID method, the community could use the [did:algo](https://github.com/algorandfoundation/did-algo) . Is now part of the DIF's (Decentralized Identify Foundation) [Universal Resolver](https://github.com/decentralized-identity/universal-resolver).

#### Use Case

When creating a DID, the wallet **MUST** be able to associate the DID with a dedicated public key and as part of the DIDocument, the wallet can provide proof of ownership of all public keys /addresses that could be involved in payment operations. 

##### Address proof

Using [ARC-52](https://github.com/algorandfoundation/ARCs/pull/239/) any wallet will be able to generate signatures to prove ownership of an address.

###### Example

With an existing signature for an address

```ts
const firstKey: Uint8Array = await cryptoService.keyGen(
  KeyContext.Payments,
  0,
  0
);

// sample 32 byte public key: 0x0102030405060708091011121314151617181920212223242526272829303132
 
// sign the address
const signature: Uint8Array = await cryptoService.signData(
  KeyContext.Payments,
  0,
  0,
  address
);

// sample 64 byte signature: 0x01020304050607080910111213141516171819202122232425262728293031320102030405060708091011121314151617181920212223242526272829303132
```

add to the DIDocument:

```json
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ],
  "id": "did:algo:123456789abcdefghi-351121",
  "keys": [
    {
        "id": "did:algo:123456789abcdefghi-351121#key-1",
        "type": "Ed25519VerificationKey2020",
        "controller": "did:algo:123456789abcdefghi-351121",
        "public": "0102030405060708091011121314151617181920212223242526272829303132",
        "signature": "01020304050607080910111213141516171819202122232425262728293031320102030405060708091011121314151617181920212223242526272829303132"
    },
    {
        "id": "did:algo:123456789abcdefghi-351121#key-2",
        "type": "Ed25519VerificationKey2020",
        "controller": "did:algo:123456789abcdefghi-351121",
        "public": "0102030405060708091011121314151617181920212223242526272829303132",
        "signature": "01020304050607080910111213141516171819202122232425262728293031320102030405060708091011121314151617181920212223242526272829303132"
    }
  ]
}
```
### Payment Applications & Verifiers

- Applications **MUST** be able to verify the DID and the associated public keys.

#### Universal Resolver

The community use an existent [Universal Resolver](https://github.com/decentralized-identity/universal-resolver) instance and the **Foundation** could run a resolver for the Algorand DID method.

Using the universal resolver, any application can resolve a DID and get the associated public keys, corresponding addresses and proofs of ownership.

#### KYC

With the right ecosystem partner that can offer KYC services, this can issue proof of KYC status as a [Verifiable Credential](https://www.w3.org/TR/vc-data-model/).

This would mean that this credential could be presented to any verifier, such as a payment provider, to prove that the user has been KYC'd.

Would avoid users having to go through KYC multiple times.

## Privacy