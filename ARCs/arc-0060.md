---
arc: 60
title: Algorand Wallet Structured Data Signing API
description: API function for signing structured data
author: Stefano De Angelis (@deanstef)
discussions-to: https://github.com/algorandfoundation/ARCs/issues/284
status: Draft
type: Standards Track
category: Interface
created: 2024-02-28
requires: 1
---

# Algorand Wallet Structured Data Signing API

> This ARC is inspired by [ARC-1](./arc-0001.md).

## Abstract

ARC-1 defines a standard for signing Algorand transactions that are represented as structured objects. This proposal extends the signing process to byte arrays encoded with a standardized structure.

[ARC-60](./arc-0060.md) defines an API for wallets to sign structured data that are not Algorand transactions.

## Motivation

Signing data is a common and critical operation. Users may need to sign data for multiple reasons (e.g. delegate signatures, DIDs, signing documents, authentication).

Algorand wallets need a standard approach to byte signing to unlock self-custodial services and protect users from malicious and attack-prone signing workflows.

This ARC provides a standard API for bytes signing. The API encodes byte arrays to be signed into well-structured JSON schemas together with additional metadata. It requires wallets to validate the signing inputs, notify users about what they are signing and warn them in case of dangerous signing requests.

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

> Comments like this are non-normative

### Overview

> This section is non-normative

Signatures of bytes are processed with the `signData(data, metadata, signer)` function.

`data` is a `StdDataStr` object that instantiates a JSON Schema. The schema is provided with the `metadata`, it includes the `bytes` that must be signed and an optional `prefix`.

`metadata` is a `StdSignMetadata` object that describes the signature scope, the JSON schema, and the encoding used to represent the signing bytes.

`signer` is a byte array representing the public key to use for the signing operation.

Ultimately, the function computes the message to be signed as `msg=(<prefix> || <data.bytes>)` and returns the signature `Sig(msg, sk)` where `sk` is the `signer`'s signing key.

### Interfaces

> Interfaces are defined in TypeScript. All the objects that are defined are valid JSON objects.

ARC-60 uses interchangeably the terms "throw an error" and "reject a promise with an error".

#### **Interface `SignDataFunction`**

A wallet function `signData` is defined by the interface:

```tsx
export type SignDataFunction = {
    data: StdDataStr,
    metadata: StdSignMetadata,
    signer: Ed25519Pk,
}
    => Promise<(Signature | null)>;
```

- `data` is a `StdDataStr` object representing the structured data being signed (defined below).
- `metadata` is a `StdSignMetadata` object (defined below) that provides additional information on the data being signed, the scope, a JSON schema, and the encoding.
- `signer` is a `Ed25519Pk` object (defined below) that represents the signer public key.

The `signData` function returns a `Signature` object or, in case of error, rejects the promise with an error object `SignDataError`.

#### Interface `StdDataStr`

The `StdDataStr` object is a UTF-8 encoded string that complies with the `metadata` JSON schema.

```tsx
export type StdDataStr = string;
```

The `StdDataStr` must be validated with the JSON schema in `metadata` (defined below).

#### Interface `Ed25519Pk`

An `Ed25519Pk` object is a 32-byte public key, point of the ed25519 elliptic curve. The key **MUST NOT** be transformed into an Algorand address.

```tsx
export type Ed25519Pk = Uint8Array;
```

> The wallet **MAY** want to operate directly with standard Algorand addresses. The transformation from a generic key to an Algorand address is left to the implementation. See <a href="https://developer.algorand.org/docs/get-details/accounts/#transformation-public-key-to-algorand-address">Public Key to Algorand Address</a> section of the developer portal.

#### Interface `Signature`

`Signature` is the produced 64-byte array, ed25519 digital signature of the signed message.

```tsx
export type Signature = Uint8Array;
```

#### Enum `ScopeType`

The `ScopeType` enumerates constant strings with the scope of a signing action.

This ARC introduces two scope types.

| ScopeType | Description |
| --- | --- |
| AUTH | Signature of a basic 32 bytes challenge for authentication. |
| LSIG | Signature of an Algorand program for delegation. |
| ... | ... |

For each `ScopeType` corresponds a unique JSON schema (see below).

Any extension of this ARC **SHOULD** adopt an existing `ScopeType`, or introduce a new one (with the respective JSON schema).

#### Interface `StdSignMetadata`

A `StdSignMetadata` object specifies the metadata for the `StdDataStr`.

```tsx
export interface StdSignMetadata {
    /**
    * The scope value of the signing data request.
    */
    scope: ScopeType;

    /**
    * JSON schema for the signing data.
    */
    schema: string;

    /**
    * Optional encoding used to represent the signing bytes in the schema.
    */
    encoding?: string;
}
```

- `schema` JSON schema to be used according to the `scope`. ARC-60 compliant JSON schemas have two mandatory fields:
  - `ARC60Domain` domain separator for the signing bytes.
  - `bytes` signing bytes.
- `encoding` specifies the encoding used for the `schema.bytes` field. If not specified, encoding should be `base64`.

> The JSON schema is inspired by <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712: Typed structured data hashing and signing proposal</a>.

##### Example: AUTH JSON Schema

JSON schema for signing an authentication challenge; `ScopeType=AUTH`. In this example, the `StdDataStr` **MUST** adhere to the following schema

```json
{
  "type": "object",
  "properties": {
    "ARC60Domain": {
      "type": "string",
      "description": "The ARC-60 domain separator"
    },
    "bytes": {
      "type": "array",
      "items": {
        "type": "integer",
        "minimum": 0,
        "maximum": 255
      },
      "description": "Challenge to be signed for authentication",
      "maxItems": 32
    }
  },
  "required": ["ARC60Domain", "bytes"]
}
```

- The `ARC60Domain` object indicates the domain separator to be used for signing. It **SHOULD** be set to `"arc60"` for simple bytes. Algorand transaction domain separators `TX` and `TG` **MUST** be forbidden.
- The `bytes` object is the byte array of data being signed. In the example, it is a 32-byte challenge to be signed for authentication scope. The `bytes` field cannot be a valid Algorand transaction, therefore it **MUST NOT** be prepended with a known domain separator `TX` or `TG`.

> Algorand domain separators can be found in the <a href="https://github.com/algorandfoundation/specs/blob/master/dev/crypto.md#domain-separation">Algorand specs</a> and in the <a href="https://github.com/algorand/go-algorand/blob/master/protocol/hash.go#L21">Go type HashID</a>.

A valid `StdDataStr` object for `ScopeType=AUTH` is:

```json
{
  "ARC60Domain" : "arc60",
  "bytes" : "[99, 50, 97, 57, 51, 99, ..., 57, 49, 53]"
}
```

#### Error interface `SignDataError`

The `SignDataError` object extends the `SignTxnsError` defined in [ARC-1](./arc-0001.md).

```ts
export interface SignDataError extends Error {
  code: number;
  data?: any;
  failingSignData: (StdDataStr | null);
}
```

`SignDataError` uses the same error codes of `SignTxnsError` as well as the following codes:

| Status Code | Name | Description |
| --- | --- | --- |
| 4600 | Invalid scope | The scope of the signing action is not recognized by the wallet |
| 4601 | Invalid schema | The schema does not comply with ARC-60 requirements |
| 4602 | Invalid encoding | Data cannot be decoded with the given encoding |

### Semantic Requirements

The call `signData(data, metadata, signer)` **MUST** either return the signed data `ret` or reject the call throwing an error `err`.

> Following [ARC-1](./arc-0001.md) terminology, in this ARC the term **Rejecting** means throwing an error with `err.code=4300`.

Upon calling `signData(data, metadata, signer)`:

- the `data`, `metadata`, and `signer` **MUST NOT** be `null`, otherwise the wallet **MUST** reject the call.
- `data` **MUST** be validated with respect to the JSON schema `metadata.schema`. If the validation fails, the call **MUST** be rejected with a `4300` error.
- if the encoding `metadata.encoding` is present, it **MUST** be used to decode `data.bytes`.
- the wallet **MUST** prepare the signing message as `msg=(<data.bytes>)`.
  - if the value of `ARC60Domain` is not empty than it must used as `prefix`: `msg=(<prefix> || <data.bytes>)`.
- the wallet **MUST** ask users for signing confirmation. It **MUST** display a message (defined in Display message) providing the `ScopeType`, `signer`, and the `msg` being signed:
  - if the user approves, `msg` **MUST** be signed with the `signer`'s key and `ret` **MUST** be set to the corresponding `Signature`.
  - if the user rejects, the call **MUST** fail with error code `4001`.

Note that if `msg` cannot be signed for any reason, the wallet **MUST** throw an error, such that

- `err.message` **SHOULD** indicate the reason for the error (e.g. specify that `data` is not a valid JSON object according to `metadata.schema`)
- `err.failingSignData` **SHOULD** return the `StdDataStr` object that caused the error, otherwise `null`.

#### Semantic of `data`

- it **MUST** be a valid `StdDataStr` object, otherwise the wallet **MUST** reject.
- it **MUST** be UTF-8 encoded.
- it **MUST** adhere to `metadata.schema`, otherwise the wallet **MUST** reject.
- the `ARC60Domain` field must be validated against forbidden values:
  - the wallet **MUST** reject if `ARC60Domain="TX"`.
  - the wallet **MUST** reject if `ARC60Domain="TG"`.
- `data.bytes` must be a valid byte string:
  - it **MUST** be encoded as `metadata.encoding` if present, otherwise `base64`.
  - the wallet **MUST** throw a `4602` error if the decoding fails with the given encoding value.
  - the wallet **MUST** reject if the `data.bytes` field is prepended with a forbidden domain separator `TX` or `TG`.

#### Semantic of `metadata`

- `scope`:
  - it **MUST** be a valid `ScopeType` string, otherwise the wallet **MUST** throw a `4600` error.

- `schema`:
  - it **MUST** be a JSON schema with the properties `ARC60Domain` and `bytes`, otherwise the wallet **MUST** throw a `4601` error.

- `encoding`:
  - if specified, it **MUST** be used to encode `data.bytes`.

#### Semantic of `signer`

- it **MUST** be a valid `Ed25519Pk` object, otherwise the wallet **MUST** reject.
- the wallet **MUST** reject if the `signer` is unknown.

#### General Validation

Every input of the `signData(data, metadata, signer)` must be validated.

The validation:

- **SHALL NOT** rely on TypeScript typing as this can be bypassed. Types **MUST** be manually verified.
- **SHALL NOT** assume that the provided `data` complies with the respective `metadata.schema`. The schema **MUST** be manually verified and all the required parameters **MUST** be checked.
- **SHALL NOT** assume to compute signatures with the Algorand SDK `signBytes` function. There is no indirect validation of the passed `data` and `metadata` objects on that function. In general, the validation **SHALL NOT** rely on underlying SDKs to validate the inputs of an ARC-60 signing operation.

#### Display message

The wallet **MUST** display a message for any signing request. The message **MUST** be computed dynamically taking as inputs the `metadata.scope`, the `signer`, and the message being signed `msg`.

> The `message` structure is left to the implementation. An example is:
>
> `You are about to sign <msg> with scope <metadata.scope> and signer <signer>`.

The wallet **SHOULD** display a warning in the message if the `ScopeType` is a `LSIG`.

## Rationale

This API was designed to enable the secure signing of structured data with Algorand wallets. The API:

- Is generic to _pure_ ed25519 key pairs and does not require key manipulation
- Is easy to extend with custom JSON schema to support future signing use cases (e.g. authentication)
- Is secure by design preventing malicious applications from tricking users into signing malicious data or in the worst cases approving malicious transactions.

This API was not designed to sign Algorand transactions or a group of transactions (see ARC-1 instead).

## Backwards Compatibility

This ARC is not backward compatible with [ARC-47](./arc-0047.md) Logic Signature Template.

ARC-47 introduces the method `algo_templatedLsig` that takes a `LogicSignatureDescription` object and returns the signature of a logic signature program for delegation.

An alternative using the ARC-60 `signData()` is given below, where:

- `data` **MUST** specify:
  - the `LogicSignatureDescription` object as detailed in ARC-47
  - the `values` of the templated variables and the `hash` of the expected program
  - the `ARC60Domain` must be set to the domain separator `"Program"`, as specified in the <a href="https://github.com/algorandfoundation/specs/blob/master/dev/crypto.md#domain-separation">Algorand specs</a>.

- `metadata` **MUST** specify:
  - an extended ARC-60 compatible JSON schema
  - `ScopeType` is set to `LSIG`.

The extended schema can be found in the `../assets/arc-0060` folder with the file [lsig-schema.json](../assets/arc-0060/lsig-schema.json).

### Semantics for signing a Logic Signature

- if the `metadata.scope` is set to `LSIG`:
  - the `ARC60Domain` value **MUST** be equal to the byte array corresponding to the prefix `"Program"`.
  - the JSON schema **MUST** define the `data.bytes` field as an array of objects, such as the `LogicSignatureDescription`, `values`, and `hash`.
  - the wallet **MUST** follow the ARC-47 specification: compile the program from the received template and check its integrity with the `hash`.
  - the compiled program **MUST** be used with the prefix to compute the signing message `msg`, as `msg="Program" || <compiled_lsig>`.

## Test Cases

N/A

## Reference Implementation

A reference implementation is available in the `../assets/arc-0060` folder.

- [auth-schema.json](../assets/arc-0060/simple-schema.json) provides the ARC-60 JSON schema for `ScopeType=AUTH`.
- [lsig-schema.json](../assets/arc-0060/lsig-schema.json) provides the ARC-60 JSON schema for `ScopeType=LSIG`.
- [wallet.ts](../assets/arc-0060/wallet.ts) contains a simple TypeScript script showing how wallets can implement the `SignDataFunction` interface.

## Security Considerations

Users signing bytes can be tricked into signing malicious messages being exposed to man-in-the-middle attacks.

Users must be aware of what they are signing and for what purpose. The wallet **MUST** always compute a new message dynamically according to the received `data` and `metadata`. This prevents the injection of malicious or misleading messages and provides a clear scope of the signing action.

Wallets only support known `ScopeTypes` and schemas. It ensures that signing actions have a clear scope and mitigates the risk of producing unexpected signatures.

## Copyright

Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
