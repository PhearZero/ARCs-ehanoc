---
arc: 52
title: Wallet Contextual KeyGen and Signing
description: Algorand Wallet API for Contextual KeyGen and Signing
author: Bruno Martins (@ehanoc)
discussions-to: https://github.com/algorandfoundation/ARCs/issues/239
status: Draft
type: Standards Track
category: Interface
created: 2023-06-30
requires: 44
---

# Algorand Wallet Contextual KeyGen and Signing

## Abstract

This document specifies an expansion of the Algorand Wallet API to support contextual key generation and signing for **non-algorand-transaction** contexts.

## Motivation

At it's core, blockchain keys and signatures are just implementations of cryptographic primitives. These primitives can be used for a wide variety of use cases, not just for the purpose of signing transactions. And wallets being applications that contain or serve as Key Management Systems (KMS), should be able to support a multiple of other use cases that are not just related to transactions. This creates the possibility of attaching on-chain behavior with off-chain behavior, allowing for example to concepts of Identity and Authentication.

The current wallet APIs available only support key derivation for addresses and signing for transactions. In the broader context of Algorand and web3 ecosystems, there is a need for a more flexible API that allows for contextual key generation and signing. An example of this could be identity dedicated keys (i.e DIDs), or passkeys for authentication. 

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

> Comments like this are non-normative.

### Overview

> This overview section is non-normative.

At a high level this specification defines a new API to generate keys and signing in other contexts than transactions. 

> Interfaces are defined in TypeScript. All the objects that are defined are valid JSON objects.


#### Contexts 

An enum of contexts that are supported by the wallet. This enum is extensible and can be expanded in the future to support more contexts (i.e messaging, ephemeral keys, other chain derivations, etc)

```ts
enum KeyContext {
    Identity = 1,
    PASSKEY = 2,
    GPG = 3,
    ...
}
```

#### BIP44 Context Derivation Paths

There is several reasons why we want to avoid key re-use in different contexts. One of the reasons is that we want to avoid the possibility of **leaking** information about the identity of the user. Another reason is that there is some cryptographic security concers when re-using keys or in case of keys being compromised the impact is **compartmentalized**. 

For this reason is advisable to have different derivation paths for different contexts supporting recoveribility of the keys by using the same mnemonic as before. 

```ts 

| Purpose | Coin Type | Account | Change | Address Index | Context             |
| :-----: | :-------: | :-----: | :----: | :-----------: | :-----------------: |
|  44'    |    0'     |    x'   |   x    |       x       | Identity Keys       |
|  67'    |    0'     |    x'   |   x    |       x       | Passkeys            |
|  68'    |    0'     |    x'   |   x    |       x       | GPG Keys            |
```

see <a href="https://github.com/algorandfoundation/ARCs/pull/224"> `arc-44` Support (BIP44)</a>

#### Wallet New Interface

This new interface is for the wallet to implement. It is an extension of the current wallet interface.

This extension is **OPTIONAL** and separate from the current interface that handles address generation and transaction signing.

```ts

interface Wallet {
    ...
    keyGen(context: KeyContext, name: string): Promise<Uint8Array>;
    sign(context: KeyContext, name: string, message: Uint8Array): Promise<Uint8Array>;
    exportGPGKey(name: string): Promise<Buffer>; // only for gpg keys
    ...
}
```

##### keyGen

Wallet API function method that derives a key in a given context. The key should be derived from the wallet's master key. The key derivation should be deterministic, meaning that the same key should be derived from the same context and name.

In order to derive a key, the wallet should lookup the different derivation paths for the given context.


- `keyGen(context: KeyContext, name: string): Promise<Uint8Array>`
    - `context` - The context of the key to be generated
    - `name` - The name of the key to be generated
    - `returns` - The public key, which is a point on the Ed25519 elliptic curve. The public key is encoded as compressed EC point: the y-coordinate, combined with the lowest bit (the parity) of the x-coordinate, making up 32 bytes. 

###### Example

```ts
const DID_publicKey: Uint8Array = await wallet.keyGen(KeyContext.Identity, "my-did");
// share DID 

```
##### sign

Signing operation that can be used to perform arbitrary signing operations in a given context. These can be for example: 

    - Identity signatures (Documents, DIDs, etc)
    - Authentication signatures (JWT, FIDO, etc)
    - Passkey signatures (Passwordless authentication)
    - GPG signatures (PGP, etc)

- `sign(context: KeyContext, name: string, message: Uint8Array): Promise<Uint8Array>`
    - `context` - The context of the key to be used for signing
    - `name` - The name of the key to be used for signing
    - `message` - The message to be signed
    - `returns` - The produced digital signature, which is 64 bytes (32 + 32 bytes). It holds a compressed point R + the integer s (confirming that the signer knows the msg and the privKey).

###### Example

```ts
// Example -> sign a document

// first create a identity key
const DID_publicKey: Uint8Array = await wallet.keyGen(KeyContext.Identity, "my-did");

// A raw representation of a document
const document: Uint8Array = new Uint8Array([1,2,3,4,5,6,7,8,9,0]);
// hash the document
const documentHash: Uint8Array = await crypto.hash(document); // some hash

// sign hash 
const signature: Uint8Array = await wallet.sign(KeyContext.Identity, "my-did", documentHash);

```

##### exportGPGKey

GPG keys are very engrained in our digital systems (i.e GIT, SSH, etc) and when these are based in Elliptic Curve cryptography at it's core, these keys are no different from the Ed25519 keys that we use to generate addresses and sign transactions.

The signature schemes might be slightly different, but the basic cryptographic primitives are the same.

Being able to derive and manage GPG keys from your wallet; that might already support keys for addresses, identity concepts, authentication, etc; is a very powerful feature as you can always recover your GPG keys from your mnemonic. 

Exporting this key, allows us to import it into already existing ecosystems that rely on GPG keys, such as GIT, SSH, etc.

- `exportGPGKey(name: string): Promise<Buffer>`
    - `name` - The name of the key to be exported
    - `returns` - The exported GPG key in cencrypted format

## Rationale

## Security Considerations

## Copyright
Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.